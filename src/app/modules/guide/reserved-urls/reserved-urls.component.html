<mat-card class="pwa-page" xmlns="http://www.w3.org/1999/html">
	<app-local-menu [localMenu]="localMenu"></app-local-menu>
	<h3 id="reversed-urls" query-selector>Зарезервированные адреса.</h3>
	<p>Firebase Hosting резервирует адреса хостируемого приложения начинающиеся с <span class="dark-red" >&#160; /&#95; &#95;</span> .  Это - зарезервированные пространство имен облегчает использование некоторых функций Firebase вместе с Firebase Hosting. Такие адреса (начинающиеся с вышеуказанных символов) доступны при развертывании и работе команды <span class="dark-blue">firebase serve</span> локально.</p>
	<h4>Библиотека Firebase SDK.</h4>
	<p>Поскольку контент хостируемого приложения раздается по протоколу <span class="dark-blue">HTTP/2</span>, можно увеличить производительность загрузки, загружая файлы с единого источника. Firebase Hosting раздает все версии библиотеки <span class="dark-blue">Firebase JS SDK</span> со специальных адресов, форматом которых является шаблон: </p>
	<app-code-example [context]="{headerColor : 'rgb(229, 229, 229)', backgroundColor : 'rgb(242, 242, 242)',headerText : 'Шаблон формирования адресов загрузки пространств имен библиотек', extension : ''}">
<pre>/__/firebase/&#123;версия_файла&#125;/&#123;имя_файла_библтотеки&#125;.js</pre></app-code-example>
	<p>Настоятельно рекомендуется загружать не весь пакет библиотеки, а только необходимые для работы пространста имен. К примеру, разработчик использует в своем проекте функциональность аутентификации и облачного хранилища, для этого нужно первым адресом подгрузить ядро библиотеки, а затем пространства имен, использующиеся в проекте. Подобным образом для загрузки доступны все версии библиотек.</p>
	<app-code-example [context]="{headerColor : 'rgb(229, 229, 229)', backgroundColor : 'rgb(242, 242, 242)',headerText : 'Скрипты подгрузки ресурсов нужных библиотек', extension : 'index.html'}">
<pre>&#60;script src=<span class="green">"/__/firebase/5.5.6/firebase-app.js"</span>&#62;&#60;/script&#62;
&#60;script src=<span class="green">"/__/firebase/5.5.6/firebase-auth.js"</span>&#62;&#60;/script&#62;
&#60;script src=<span class="green">"/__/firebase/5.5.6/firebase-storage.js"</span>&#62;&#60;/script&#62;</pre></app-code-example>
	<h4>Автоконфигурация библиотеки</h4>
	<p>Дополнительно к самим библиотекам, в зарезервированных пространствах имен находятся все настройки, необходимые для инициализации библиотеки в проекте, т.е. нет неоюходимости вызывать метод инициализации библиотеки с вложенным объектом полномочий проекта. Это обеспечивается файлом скрипта, который можно включить в приложения явно.</p>
	<app-code-example [context]="{headerColor : 'rgb(229, 229, 229)', backgroundColor : 'rgb(242, 242, 242)',headerText : 'Загрузка файла инициализации', extension : 'index.html'}">
		<pre><span class="grey">//Этот файл должен быть загружет после загрузки всех необходимых библиотек (после них).</span>
&#60;script src=<span class="green">"/__/firebase/init.js"</span>&#62;&#60;/script&#62;</pre></app-code-example>
	<p>Этот скрипт автоматически сконфигурирует приложение, основываясь на файле конфигурации, который известен серверу по умолчанию. Но, если разработчик предпочитает контролировать инициализацию, файл конфигурации так же доступен по адресу ниже, в виде <span class="dark-blue">json</span> файла. Автоконфигурация облегчает управление несколькими контекстами (разработка, репетиционный сервер, продакшн) из одной кодовой бызы. Полагаясь на зарезервированные адреса можно развертывать одинаковый код в несколько Firebase проектов.</p>
	<app-code-example [context]="{headerColor : 'rgb(229, 229, 229)', backgroundColor : 'rgb(242, 242, 242)',headerText : 'Загрузка файла конфигурациии и инициализация проекта', extension : '.js'}">
		<pre>fetch(<span class="green" >'/__/firebase/init.json'</span>).then(<span class="dark-red" >response</span> => &#123;
   firebase.initializeApp(<span class="dark-red" >response</span>.json());
&#125;);</pre></app-code-example>
	<h4>Зарезервированные адреса и сервисные рабочие</h4>
	<p>Если разрабатывается приложение PWA ( Progressive Web App ), можно написать сервисного рабочего, который имеет запасной адрес из которого подавать некоторый контент по умолчанию, в случае если запрошенный адрес не входит в список предварительного кэширования. <b>Разработчик должен отключить откат на запрос по зарезервированному адресу для Firebase Hosting.</b> Если в PWA приложении использутся библиотека предварительного кэширования <span class="dark-blue">sw-precache</span>, то можно добавить зарезервированный адрес в настройки белого списка. Вообщем, нужно просто помнить, что корень и двойное подчеркивание - это пространство имен, зарезервинованное за Firebase Hosting, и сервисный рабочий должен обрабатывать и эти адреса. </p>
	<app-code-example [context]="{headerColor : 'rgb(229, 229, 229)', backgroundColor : 'rgb(242, 242, 242)',headerText : 'Включение зарезервированного адреса в белый список', extension : '.js'}">
		<pre>&#123;
  navigateFallbackWhitelist: [/^(?!\/__).*/]
&#125;;</pre></app-code-example>
</mat-card>
